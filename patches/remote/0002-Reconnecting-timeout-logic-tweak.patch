From 1b8f95f66ae1c3ed2c7040304f0a373289da1a65 Mon Sep 17 00:00:00 2001
From: James <aslan.jnn@gmail.com>
Date: Sat, 25 Mar 2023 21:34:44 +1100
Subject: Tweak remote reconnecting timeout

---
 .../remote/common/remoteAgentConnection.ts    | 58 +++++++++----------
 .../contrib/remote/browser/remote.ts          |  2 +-
 2 files changed, 29 insertions(+), 31 deletions(-)

diff --git a/src/vs/platform/remote/common/remoteAgentConnection.ts b/src/vs/platform/remote/common/remoteAgentConnection.ts
index bbbddcc39d5..c2d24eab3d9 100644
--- a/src/vs/platform/remote/common/remoteAgentConnection.ts
+++ b/src/vs/platform/remote/common/remoteAgentConnection.ts
@@ -20,7 +20,7 @@ import { RemoteAuthorityResolverError } from 'vs/platform/remote/common/remoteAu
 import { getRemoteServerRootPath } from 'vs/platform/remote/common/remoteHosts';
 import { ISignService } from 'vs/platform/sign/common/sign';

-const RECONNECT_TIMEOUT = 30 * 1000 /* 30s */;
+const RECONNECT_TIMEOUT = 15 * 1000; // in milliseconds

 export const enum ConnectionType {
 	Management = 1,
@@ -98,16 +98,6 @@ function createTimeoutCancellation(millis: number): CancellationToken {
 	return source.token;
 }

-function combineTimeoutCancellation(a: CancellationToken, b: CancellationToken): CancellationToken {
-	if (a.isCancellationRequested || b.isCancellationRequested) {
-		return CancellationToken.Cancelled;
-	}
-	const source = new CancellationTokenSource();
-	a.onCancellationRequested(() => source.cancel());
-	b.onCancellationRequested(() => source.cancel());
-	return source.token;
-}
-
 class PromiseWithTimeout<T> {

 	private _state: 'pending' | 'resolved' | 'rejected' | 'timedout';
@@ -237,12 +227,15 @@ function raceWithTimeoutCancellation<T>(promise: Promise<T>, timeoutCancellation
 	return result.promise;
 }

-async function connectToRemoteExtensionHostAgent(options: ISimpleConnectionOptions, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; ownsProtocol: boolean }> {
+async function connectToRemoteExtensionHostAgent(options: ISimpleConnectionOptions, connectionType: ConnectionType, args: any | undefined): Promise<{ protocol: PersistentProtocol; ownsProtocol: boolean }> {
 	const logPrefix = connectLogPrefix(options, connectionType);

 	options.logService.trace(`${logPrefix} 1/6. invoking socketFactory.connect().`);

+	let timeoutCancellationToken: CancellationToken;
+
 	let socket: ISocket;
+	timeoutCancellationToken = createTimeoutCancellation(RECONNECT_TIMEOUT);
 	try {
 		socket = await createSocket(options.logService, options.socketFactory, options.host, options.port, getRemoteServerRootPath(options), `reconnectionToken=${options.reconnectionToken}&reconnection=${options.reconnectionProtocol ? 'true' : 'false'}`, connectionTypeToString(connectionType), `renderer-${connectionTypeToString(connectionType)}-${options.reconnectionToken}`, timeoutCancellationToken);
 	} catch (error) {
@@ -265,6 +258,7 @@ async function connectToRemoteExtensionHostAgent(options: ISimpleConnectionOptio
 	}

 	options.logService.trace(`${logPrefix} 3/6. sending AuthRequest control message.`);
+	timeoutCancellationToken = createTimeoutCancellation(RECONNECT_TIMEOUT);
 	const message = await raceWithTimeoutCancellation(options.signService.createNewMessage(generateUuid()), timeoutCancellationToken);

 	const authRequest: AuthRequest = {
@@ -274,8 +268,9 @@ async function connectToRemoteExtensionHostAgent(options: ISimpleConnectionOptio
 	};
 	protocol.sendControl(VSBuffer.fromString(JSON.stringify(authRequest)));

+	timeoutCancellationToken = createTimeoutCancellation(RECONNECT_TIMEOUT);
 	try {
-		const msg = await readOneControlMessage<HandshakeMessage>(protocol, combineTimeoutCancellation(timeoutCancellationToken, createTimeoutCancellation(10000)));
+		const msg = await readOneControlMessage<HandshakeMessage>(protocol, timeoutCancellationToken);

 		if (msg.type !== 'sign' || typeof msg.data !== 'string') {
 			const error: any = new Error('Unexpected handshake message');
@@ -285,6 +280,7 @@ async function connectToRemoteExtensionHostAgent(options: ISimpleConnectionOptio

 		options.logService.trace(`${logPrefix} 4/6. received SignRequest control message.`);

+		timeoutCancellationToken = createTimeoutCancellation(RECONNECT_TIMEOUT);
 		const isValid = await raceWithTimeoutCancellation(options.signService.validate(message, msg.signedData), timeoutCancellationToken);
 		if (!isValid) {
 			const error: any = new Error('Refused to connect to unsupported server');
@@ -292,6 +288,7 @@ async function connectToRemoteExtensionHostAgent(options: ISimpleConnectionOptio
 			throw error;
 		}

+		timeoutCancellationToken = createTimeoutCancellation(RECONNECT_TIMEOUT);
 		const signed = await raceWithTimeoutCancellation(options.signService.sign(msg.data), timeoutCancellationToken);
 		const connTypeRequest: ConnectionTypeRequest = {
 			type: 'connectionType',
@@ -328,10 +325,11 @@ interface IManagementConnectionResult {
 	protocol: PersistentProtocol;
 }

-async function connectToRemoteExtensionHostAgentAndReadOneMessage<T>(options: ISimpleConnectionOptions, connectionType: ConnectionType, args: any | undefined, timeoutCancellationToken: CancellationToken): Promise<{ protocol: PersistentProtocol; firstMessage: T }> {
+async function connectToRemoteExtensionHostAgentAndReadOneMessage<T>(options: ISimpleConnectionOptions, connectionType: ConnectionType, args: any | undefined): Promise<{ protocol: PersistentProtocol; firstMessage: T }> {
 	const startTime = Date.now();
 	const logPrefix = connectLogPrefix(options, connectionType);
-	const { protocol, ownsProtocol } = await connectToRemoteExtensionHostAgent(options, connectionType, args, timeoutCancellationToken);
+	const { protocol, ownsProtocol } = await connectToRemoteExtensionHostAgent(options, connectionType, args);
+	const timeoutCancellationToken: CancellationToken = createTimeoutCancellation(RECONNECT_TIMEOUT);
 	const result = new PromiseWithTimeout<{ protocol: PersistentProtocol; firstMessage: T }>(timeoutCancellationToken);
 	result.registerDisposable(protocol.onControlMessage(raw => {
 		const msg: T = JSON.parse(raw.toString());
@@ -352,8 +350,8 @@ async function connectToRemoteExtensionHostAgentAndReadOneMessage<T>(options: IS
 	return result.promise;
 }

-async function doConnectRemoteAgentManagement(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<IManagementConnectionResult> {
-	const { protocol } = await connectToRemoteExtensionHostAgentAndReadOneMessage(options, ConnectionType.Management, undefined, timeoutCancellationToken);
+async function doConnectRemoteAgentManagement(options: ISimpleConnectionOptions): Promise<IManagementConnectionResult> {
+	const { protocol } = await connectToRemoteExtensionHostAgentAndReadOneMessage(options, ConnectionType.Management, undefined);
 	return { protocol };
 }

@@ -370,8 +368,8 @@ interface IExtensionHostConnectionResult {
 	debugPort?: number;
 }

-async function doConnectRemoteAgentExtensionHost(options: ISimpleConnectionOptions, startArguments: IRemoteExtensionHostStartParams, timeoutCancellationToken: CancellationToken): Promise<IExtensionHostConnectionResult> {
-	const { protocol, firstMessage } = await connectToRemoteExtensionHostAgentAndReadOneMessage<{ debugPort?: number }>(options, ConnectionType.ExtensionHost, startArguments, timeoutCancellationToken);
+async function doConnectRemoteAgentExtensionHost(options: ISimpleConnectionOptions, startArguments: IRemoteExtensionHostStartParams): Promise<IExtensionHostConnectionResult> {
+	const { protocol, firstMessage } = await connectToRemoteExtensionHostAgentAndReadOneMessage<{ debugPort?: number }>(options, ConnectionType.ExtensionHost, startArguments);
 	const debugPort = firstMessage && firstMessage.debugPort;
 	return { protocol, debugPort };
 }
@@ -381,10 +379,10 @@ export interface ITunnelConnectionStartParams {
 	port: number;
 }

-async function doConnectRemoteAgentTunnel(options: ISimpleConnectionOptions, startParams: ITunnelConnectionStartParams, timeoutCancellationToken: CancellationToken): Promise<PersistentProtocol> {
+async function doConnectRemoteAgentTunnel(options: ISimpleConnectionOptions, startParams: ITunnelConnectionStartParams): Promise<PersistentProtocol> {
 	const startTime = Date.now();
 	const logPrefix = connectLogPrefix(options, ConnectionType.Tunnel);
-	const { protocol } = await connectToRemoteExtensionHostAgent(options, ConnectionType.Tunnel, startParams, timeoutCancellationToken);
+	const { protocol } = await connectToRemoteExtensionHostAgent(options, ConnectionType.Tunnel, startParams);
 	options.logService.trace(`${logPrefix} 6/6. handshake finished, connection is up and running after ${logElapsed(startTime)}!`);
 	return protocol;
 }
@@ -429,7 +427,7 @@ export async function connectRemoteAgentManagement(options: IConnectionOptions,
 	return createInitialConnection(
 		options,
 		async (simpleOptions) => {
-			const { protocol } = await doConnectRemoteAgentManagement(simpleOptions, CancellationToken.None);
+			const { protocol } = await doConnectRemoteAgentManagement(simpleOptions);
 			return new ManagementPersistentConnection(options, remoteAuthority, clientId, simpleOptions.reconnectionToken, protocol);
 		}
 	);
@@ -439,7 +437,7 @@ export async function connectRemoteAgentExtensionHost(options: IConnectionOption
 	return createInitialConnection(
 		options,
 		async (simpleOptions) => {
-			const { protocol, debugPort } = await doConnectRemoteAgentExtensionHost(simpleOptions, startArguments, CancellationToken.None);
+			const { protocol, debugPort } = await doConnectRemoteAgentExtensionHost(simpleOptions, startArguments);
 			return new ExtensionHostPersistentConnection(options, startArguments, simpleOptions.reconnectionToken, protocol, debugPort);
 		}
 	);
@@ -473,7 +471,7 @@ async function createInitialConnection<T extends PersistentConnection>(options:

 export async function connectRemoteAgentTunnel(options: IConnectionOptions, tunnelRemoteHost: string, tunnelRemotePort: number): Promise<PersistentProtocol> {
 	const simpleOptions = await resolveConnectionOptions(options, generateUuid(), null);
-	const protocol = await doConnectRemoteAgentTunnel(simpleOptions, { host: tunnelRemoteHost, port: tunnelRemotePort }, CancellationToken.None);
+	const protocol = await doConnectRemoteAgentTunnel(simpleOptions, { host: tunnelRemoteHost, port: tunnelRemotePort });
 	return protocol;
 }

@@ -692,7 +690,7 @@ export abstract class PersistentConnection extends Disposable {
 				this._options.logService.info(`${logPrefix} resolving connection...`);
 				const simpleOptions = await resolveConnectionOptions(this._options, this.reconnectionToken, this.protocol);
 				this._options.logService.info(`${logPrefix} connecting to ${simpleOptions.host}:${simpleOptions.port}...`);
-				await this._reconnect(simpleOptions, createTimeoutCancellation(RECONNECT_TIMEOUT));
+				await this._reconnect(simpleOptions);
 				this._options.logService.info(`${logPrefix} reconnected!`);
 				this._onDidStateChange.fire(new ConnectionGainEvent(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), attempt + 1));

@@ -760,7 +758,7 @@ export abstract class PersistentConnection extends Disposable {
 		this.protocol.pauseSocketWriting();
 	}

-	protected abstract _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void>;
+	protected abstract _reconnect(options: ISimpleConnectionOptions): Promise<void>;
 }

 export class ManagementPersistentConnection extends PersistentConnection {
@@ -775,8 +773,8 @@ export class ManagementPersistentConnection extends PersistentConnection {
 		}, options.ipcLogger));
 	}

-	protected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {
-		await doConnectRemoteAgentManagement(options, timeoutCancellationToken);
+	protected async _reconnect(options: ISimpleConnectionOptions): Promise<void> {
+		await doConnectRemoteAgentManagement(options);
 	}
 }

@@ -791,8 +789,8 @@ export class ExtensionHostPersistentConnection extends PersistentConnection {
 		this.debugPort = debugPort;
 	}

-	protected async _reconnect(options: ISimpleConnectionOptions, timeoutCancellationToken: CancellationToken): Promise<void> {
-		await doConnectRemoteAgentExtensionHost(options, this._startArguments, timeoutCancellationToken);
+	protected async _reconnect(options: ISimpleConnectionOptions): Promise<void> {
+		await doConnectRemoteAgentExtensionHost(options, this._startArguments);
 	}
 }

diff --git a/src/vs/workbench/contrib/remote/browser/remote.ts b/src/vs/workbench/contrib/remote/browser/remote.ts
index 58084f9711e..db026f0f287 100644
--- a/src/vs/workbench/contrib/remote/browser/remote.ts
+++ b/src/vs/workbench/contrib/remote/browser/remote.ts
@@ -758,7 +758,7 @@ class ReconnectionTimer implements IDisposable {
 /**
  * The time when a prompt is shown to the user
  */
-const DISCONNECT_PROMPT_TIME = 40 * 1000; // 40 seconds
+const DISCONNECT_PROMPT_TIME = 1000; // in milliseconds

 export class RemoteAgentConnectionStatusListener extends Disposable implements IWorkbenchContribution {

--
2.37.1 (Apple Git-137.1)
